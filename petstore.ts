/**
 * Generated by orval v6.10.2 üç∫
 * Do not edit manually.
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 * OpenAPI spec version: 1.0.6
 */
import axios from "axios";
import type { AxiosRequestConfig, AxiosResponse, AxiosError } from "axios";
import { useQuery, useMutation } from "@tanstack/react-query";
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey,
} from "@tanstack/react-query";
export type LoginUserParams = { username: string; password: string };

export type GetInventory200 = { [key: string]: number };

export type UpdatePetWithFormBody = {
  /** Updated name of the pet */
  name?: string;
  /** Updated status of the pet */
  status?: string;
};

export type FindPetsByTagsParams = { tags: string[] };

export type FindPetsByStatusStatusItem =
  typeof FindPetsByStatusStatusItem[keyof typeof FindPetsByStatusStatusItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FindPetsByStatusStatusItem = {
  available: "available",
  pending: "pending",
  sold: "sold",
} as const;

export type FindPetsByStatusParams = { status: FindPetsByStatusStatusItem[] };

export type UploadFileBody = {
  /** Additional data to pass to server */
  additionalMetadata?: string;
  /** file to upload */
  file?: Blob;
};

/**
 * Pet object that needs to be added to the store
 */
export type PetBody = Pet;

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /** User Status */
  userStatus?: number;
}

/**
 * List of user object
 */
export type UserArrayBody = User[];

/**
 * Order Status
 */
export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderStatus = {
  placed: "placed",
  approved: "approved",
  delivered: "delivered",
} as const;

export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: string;
  /** Order Status */
  status?: OrderStatus;
  complete?: boolean;
}

export interface Tag {
  id?: number;
  name?: string;
}

/**
 * pet status in the store
 */
export type PetStatus = typeof PetStatus[keyof typeof PetStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PetStatus = {
  available: "available",
  pending: "pending",
  sold: "sold",
} as const;

export interface Category {
  id?: number;
  name?: string;
}

export interface Pet {
  id?: number;
  category?: Category;
  name: string;
  photoUrls: string[];
  tags?: Tag[];
  /** pet status in the store */
  status?: PetStatus;
}

export interface ApiResponse {
  code?: number;
  type?: string;
  message?: string;
}

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @deprecated
 * @summary uploads an image
 */
export const uploadFile = (
  petId: number,
  uploadFileBody: UploadFileBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<ApiResponse>> => {
  const formData = new FormData();
  if (uploadFileBody.additionalMetadata !== undefined) {
    formData.append("additionalMetadata", uploadFileBody.additionalMetadata);
  }
  if (uploadFileBody.file !== undefined) {
    formData.append("file", uploadFileBody.file);
  }

  return axios.post(`/pet/${petId}/uploadImage`, formData, options);
};

export type UploadFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadFile>>
>;
export type UploadFileMutationBody = UploadFileBody;
export type UploadFileMutationError = AxiosError<unknown>;

export const useUploadFile = <
  TError = AxiosError<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadFile>>,
    TError,
    { petId: number; data: UploadFileBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadFile>>,
    { petId: number; data: UploadFileBody }
  > = (props) => {
    const { petId, data } = props ?? {};

    return uploadFile(petId, data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof uploadFile>>,
    TError,
    { petId: number; data: UploadFileBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Add a new pet to the store
 */
export const addPet = (
  petBody: PetBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.post(`/pet`, petBody, options);
};

export type AddPetMutationResult = NonNullable<
  Awaited<ReturnType<typeof addPet>>
>;
export type AddPetMutationBody = PetBody;
export type AddPetMutationError = AxiosError<void>;

export const useAddPet = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addPet>>,
    TError,
    { data: PetBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addPet>>,
    { data: PetBody }
  > = (props) => {
    const { data } = props ?? {};

    return addPet(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof addPet>>,
    TError,
    { data: PetBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Update an existing pet
 */
export const updatePet = (
  petBody: PetBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.put(`/pet`, petBody, options);
};

export type UpdatePetMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePet>>
>;
export type UpdatePetMutationBody = PetBody;
export type UpdatePetMutationError = AxiosError<void>;

export const useUpdatePet = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePet>>,
    TError,
    { data: PetBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePet>>,
    { data: PetBody }
  > = (props) => {
    const { data } = props ?? {};

    return updatePet(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof updatePet>>,
    TError,
    { data: PetBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 */
export const findPetsByStatus = (
  params: FindPetsByStatusParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Pet[]>> => {
  return axios.get(`/pet/findByStatus`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getFindPetsByStatusQueryKey = (params: FindPetsByStatusParams) => [
  `/pet/findByStatus`,
  ...(params ? [params] : []),
];

export type FindPetsByStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof findPetsByStatus>>
>;
export type FindPetsByStatusQueryError = AxiosError<void>;

export const useFindPetsByStatus = <
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = AxiosError<void>
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof findPetsByStatus>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindPetsByStatusQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findPetsByStatus>>
  > = ({ signal }) => findPetsByStatus(params, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof findPetsByStatus>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @deprecated
 * @summary Finds Pets by tags
 */
export const findPetsByTags = (
  params: FindPetsByTagsParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Pet[]>> => {
  return axios.get(`/pet/findByTags`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getFindPetsByTagsQueryKey = (params: FindPetsByTagsParams) => [
  `/pet/findByTags`,
  ...(params ? [params] : []),
];

export type FindPetsByTagsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findPetsByTags>>
>;
export type FindPetsByTagsQueryError = AxiosError<void>;

export const useFindPetsByTags = <
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = AxiosError<void>
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof findPetsByTags>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPetsByTagsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findPetsByTags>>> = ({
    signal,
  }) => findPetsByTags(params, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof findPetsByTags>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Returns a single pet
 * @summary Find pet by ID
 */
export const getPetById = (
  petId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Pet>> => {
  return axios.get(`/pet/${petId}`, options);
};

export const getGetPetByIdQueryKey = (petId: number) => [`/pet/${petId}`];

export type GetPetByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPetById>>
>;
export type GetPetByIdQueryError = AxiosError<void>;

export const useGetPetById = <
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = AxiosError<void>
>(
  petId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getPetById>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPetByIdQueryKey(petId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPetById>>> = ({
    signal,
  }) => getPetById(petId, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getPetById>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!petId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Updates a pet in the store with form data
 */
export const updatePetWithForm = (
  petId: number,
  updatePetWithFormBody: UpdatePetWithFormBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  const formUrlEncoded = new URLSearchParams();
  if (updatePetWithFormBody.name !== undefined) {
    formUrlEncoded.append("name", updatePetWithFormBody.name);
  }
  if (updatePetWithFormBody.status !== undefined) {
    formUrlEncoded.append("status", updatePetWithFormBody.status);
  }

  return axios.post(`/pet/${petId}`, formUrlEncoded, options);
};

export type UpdatePetWithFormMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePetWithForm>>
>;
export type UpdatePetWithFormMutationBody = UpdatePetWithFormBody;
export type UpdatePetWithFormMutationError = AxiosError<void>;

export const useUpdatePetWithForm = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    TError,
    { petId: number; data: UpdatePetWithFormBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    { petId: number; data: UpdatePetWithFormBody }
  > = (props) => {
    const { petId, data } = props ?? {};

    return updatePetWithForm(petId, data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    TError,
    { petId: number; data: UpdatePetWithFormBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Deletes a pet
 */
export const deletePet = (
  petId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`/pet/${petId}`, options);
};

export type DeletePetMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePet>>
>;

export type DeletePetMutationError = AxiosError<void>;

export const useDeletePet = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePet>>,
    TError,
    { petId: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePet>>,
    { petId: number }
  > = (props) => {
    const { petId } = props ?? {};

    return deletePet(petId, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof deletePet>>,
    TError,
    { petId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Place an order for a pet
 */
export const placeOrder = (
  order: Order,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Order>> => {
  return axios.post(`/store/order`, order, options);
};

export type PlaceOrderMutationResult = NonNullable<
  Awaited<ReturnType<typeof placeOrder>>
>;
export type PlaceOrderMutationBody = Order;
export type PlaceOrderMutationError = AxiosError<void>;

export const usePlaceOrder = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof placeOrder>>,
    TError,
    { data: Order },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof placeOrder>>,
    { data: Order }
  > = (props) => {
    const { data } = props ?? {};

    return placeOrder(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof placeOrder>>,
    TError,
    { data: Order },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * For valid response try integer IDs with value >= 1 and <= 10. Other values will generated exceptions
 * @summary Find purchase order by ID
 */
export const getOrderById = (
  orderId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<Order>> => {
  return axios.get(`/store/order/${orderId}`, options);
};

export const getGetOrderByIdQueryKey = (orderId: number) => [
  `/store/order/${orderId}`,
];

export type GetOrderByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOrderById>>
>;
export type GetOrderByIdQueryError = AxiosError<void>;

export const useGetOrderById = <
  TData = Awaited<ReturnType<typeof getOrderById>>,
  TError = AxiosError<void>
>(
  orderId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getOrderById>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetOrderByIdQueryKey(orderId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({
    signal,
  }) => getOrderById(orderId, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof getOrderById>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!orderId,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * For valid response try integer IDs with positive integer value. Negative or non-integer values will generate API errors
 * @summary Delete purchase order by ID
 */
export const deleteOrder = (
  orderId: number,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`/store/order/${orderId}`, options);
};

export type DeleteOrderMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteOrder>>
>;

export type DeleteOrderMutationError = AxiosError<void>;

export const useDeleteOrder = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteOrder>>,
    TError,
    { orderId: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteOrder>>,
    { orderId: number }
  > = (props) => {
    const { orderId } = props ?? {};

    return deleteOrder(orderId, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteOrder>>,
    TError,
    { orderId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Returns a map of status codes to quantities
 * @summary Returns pet inventories by status
 */
export const getInventory = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<GetInventory200>> => {
  return axios.get(`/store/inventory`, options);
};

export const getGetInventoryQueryKey = () => [`/store/inventory`];

export type GetInventoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInventory>>
>;
export type GetInventoryQueryError = AxiosError<unknown>;

export const useGetInventory = <
  TData = Awaited<ReturnType<typeof getInventory>>,
  TError = AxiosError<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getInventory>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetInventoryQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getInventory>>> = ({
    signal,
  }) => getInventory({ signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof getInventory>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithArrayInput = (
  userArrayBody: UserArrayBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.post(`/user/createWithArray`, userArrayBody, options);
};

export type CreateUsersWithArrayInputMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUsersWithArrayInput>>
>;
export type CreateUsersWithArrayInputMutationBody = UserArrayBody;
export type CreateUsersWithArrayInputMutationError = AxiosError<void>;

export const useCreateUsersWithArrayInput = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    { data: UserArrayBody }
  > = (props) => {
    const { data } = props ?? {};

    return createUsersWithArrayInput(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithListInput = (
  userArrayBody: UserArrayBody,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.post(`/user/createWithList`, userArrayBody, options);
};

export type CreateUsersWithListInputMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUsersWithListInput>>
>;
export type CreateUsersWithListInputMutationBody = UserArrayBody;
export type CreateUsersWithListInputMutationError = AxiosError<void>;

export const useCreateUsersWithListInput = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    { data: UserArrayBody }
  > = (props) => {
    const { data } = props ?? {};

    return createUsersWithListInput(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Get user by user name
 */
export const getUserByName = (
  username: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<User>> => {
  return axios.get(`/user/${username}`, options);
};

export const getGetUserByNameQueryKey = (username: string) => [
  `/user/${username}`,
];

export type GetUserByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserByName>>
>;
export type GetUserByNameQueryError = AxiosError<void>;

export const useGetUserByName = <
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = AxiosError<void>
>(
  username: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserByName>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByNameQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByName>>> = ({
    signal,
  }) => getUserByName(username, { signal, ...axiosOptions });

  const query = useQuery<
    Awaited<ReturnType<typeof getUserByName>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!username,
    ...queryOptions,
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * This can only be done by the logged in user.
 * @summary Updated user
 */
export const updateUser = (
  username: string,
  user: User,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.put(`/user/${username}`, user, options);
};

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>;
export type UpdateUserMutationBody = User;
export type UpdateUserMutationError = AxiosError<void>;

export const useUpdateUser = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { username: string; data: User },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { username: string; data: User }
  > = (props) => {
    const { username, data } = props ?? {};

    return updateUser(username, data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { username: string; data: User },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * This can only be done by the logged in user.
 * @summary Delete user
 */
export const deleteUser = (
  username: string,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`/user/${username}`, options);
};

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>;

export type DeleteUserMutationError = AxiosError<void>;

export const useDeleteUser = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { username: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return deleteUser(username, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { username: string },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Logs user into the system
 */
export const loginUser = (
  params: LoginUserParams,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<string>> => {
  return axios.get(`/user/login`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getLoginUserQueryKey = (params: LoginUserParams) => [
  `/user/login`,
  ...(params ? [params] : []),
];

export type LoginUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof loginUser>>
>;
export type LoginUserQueryError = AxiosError<void>;

export const useLoginUser = <
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = AxiosError<void>
>(
  params: LoginUserParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof loginUser>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLoginUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof loginUser>>> = ({
    signal,
  }) => loginUser(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof loginUser>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Logs out current logged in user session
 */
export const logoutUser = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.get(`/user/logout`, options);
};

export const getLogoutUserQueryKey = () => [`/user/logout`];

export type LogoutUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof logoutUser>>
>;
export type LogoutUserQueryError = AxiosError<void>;

export const useLogoutUser = <
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = AxiosError<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof logoutUser>>,
    TError,
    TData
  >;
  axios?: AxiosRequestConfig;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogoutUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logoutUser>>> = ({
    signal,
  }) => logoutUser({ signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof logoutUser>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * This can only be done by the logged in user.
 * @summary Create user
 */
export const createUser = (
  user: User,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.post(`/user`, user, options);
};

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>;
export type CreateUserMutationBody = User;
export type CreateUserMutationError = AxiosError<void>;

export const useCreateUser = <
  TError = AxiosError<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: User },
    TContext
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: User }
  > = (props) => {
    const { data } = props ?? {};

    return createUser(data, axiosOptions);
  };

  return useMutation<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: User },
    TContext
  >(mutationFn, mutationOptions);
};
